;;
(setq ELITE_PART 0.1) ;; part of the population that is cloned from one generation to the next
(defstruct _Population_  genotypes  size) 
(defun population_create (pop_size gen_size)
  (let ((p (instantiate _Population_)))
    (setq (p . size) pop_size)
    (setq genotype_size gen_size)
    (setq (p . genotypes) (instantiate vector pop_size))
    (dotimes (i pop_size) (setf (elt (p . genotypes) i) (genotype_create)))
    p))
(defun population_select_parent (p);; rank selection: the population need to be sorted by fitness
  (while t
    (let ((index (random_get_integer (p . size))))
      (if (<= index (random_get_integer (p . size)))
	  (return-from population_select_parent (elt (p . genotypes) index))))))
(defun compare_genotype (a b) (> (a . fitness) (b . fitness)))
(defun population_reproduce (p)
  (let ((next_generation (instantiate vector (p . size))))
    (setq (p . genotypes) (sort (p . genotypes) #'compare_genotype))
    (dotimes (i (p . size))
      (let (child mom dad)
	(cond
	 ((< i  (* ELITE_PART (p . size)))  ;; cloned elite
	  (setq child (genotype_clone (elt (p . genotypes) i))) )
	 (t (setq mom (population_select_parent p)) (setq dad (population_select_parent p))
	    (setq child (genotype_crossover mom dad))
	    (genotype_mutate child)))
	(setq (child . fitness) 0.0)
	(setf (elt next_generation i) child)))
    (setq (p . genotypes) next_generation)))
(defun population_get_fittest (p)
  (let ((fittest (elt (p . genotypes) 0)) candidate)
    (do ((i 1 (1+ i)))
	((>= i (p . size)))
	(setq candidate (elt (p . genotypes) i))
	(if (> (candidate . fitness) (fittest . fitness))
	    (setq fittest candidate)))
    fittest))
(defun population_get_genotype (p index) (elt (p . genotypes) index))
(defun population_compute_average_fitness (p)
  (let ((sum_fitness 0.0))
    (dotimes (i (p . size))
      (incf sum_fitness ((elt (p . genotypes) i) . fitness)))
    (/ sum_fitness (p . size))))
