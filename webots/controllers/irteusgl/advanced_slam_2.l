;;
;;#include "../../lib/odometry.h"
(load "webotslib.l")
(defconstant LEFT 0)
(defconstant RIGHT 1)
(defconstant TIME_STEP 64)
(defconstant PI 3.141592653589793)
(defconstant NB_DIST_SENS 8)
(defconstant MAP_SIZE 35)     ;; N by N square grid
(defconstant CELL_SIZE 0.03)  ;; => X [m] width and height
(defconstant THRESHOLD 90)
(defconstant SPEED_UNIT 0.00628)
(defconstant ENCODER_UNIT 159.23)
;;WbDeviceTag left_motor, right_motor, left_position_sensor, right_position_sensor;
;; Instantiate odometry track and goto structures
;; struct sOdometryTrack ot;

;; The map structure (just an integer array)
(setq map (make-array MAP_SIZE MAP_SIZE))
;; the robot position on the map
(setq robot_x (/ MAP_SIZE 2))
(setq robot_y (/ MAP_SIZE 2))
;; the odometry model (same size as the map)
(setq om (make-matrix MAP_SIZE MAP_SIZE))
;; the sensor model (same size as the map)
(setq sm (make-matrix MAP_SIZE MAP_SIZE))
(setq sm_inv (make-matrix MAP_SIZE MAP_SIZE))  // 1 - sm

;; the prediciotn
(setq prediction (make-matrix MAP_SIZE MAP_SIZE))
;; the belief (same size as the map)
(setq belief (make-matrix MAP_SIZE MAP_SIZE))
;; braitenberg weights for wall following
(setq weights_left (float-vector -1 -1 -1 0.5 -0.5 0.5 1 2))
(setq weights_right (float-vector 1 0.8 1 -0.5 0.5 -1 -1.6 -2))
(setq bias_left_follow (float-vector 0 0 0 0 0 -700 0 0))
(defun init_display nil
  (setq display (wb_robot_get_device "display"))
  (setq display_width (wb_display_get_width display))
  (setq display_height (wb_display_get_height display))
  (wb_display_set_color display #x808080)
  (wb_display_fill_rectangle display 0 0 display_width display_height)
  (wb_display_set_color display 0xFFFFFF)
  (wb_display_fill_rectangle display 0 0 MAP_SIZE MAP_SIZE)
  ;; display the walls in black
  (wb_display_set_color display #x000000)
  (dotimes (i MAP_SIZE)
    (dotimes (j MAP_SIZE)
      (if (= (aref map i j) 1)
	  (wb_display_draw_rectangle display  (- i 1) j 1 1))))
  (setq background (wb_display_image_copy display 0 0 display_width display_height))
  )

(defun draw_on_display (max)
  (if (= max 0.0) (return-from 'draw_on_display nil))
  (wb_display_image_paste display background 0 0 0)  ;; false=0
  (wb_display_set_opacity display 0.5)
  ;; if the belief is uniform and 0 we plot red on all location
  (dotimes (i MAP_SIZE)
    (dotimes (j MAP_SIZE)
      (cond
       ((= (aref belief (- MAP_SIZE i 1) j) max)
        (wb_display_set_color display #x00FFFF)
        (wb_display_draw_rectangle display i j 1 1))
       (t
        (setq b (* 255 (- 1 (/ (aref belief (- MAP_SIZE i 1) j) max))))
        (setq g b)
	(wb_display_set_color display (+ #xFF0000 (ash g 8) b))
        (wb_display_draw_rectangle display i j 1 1)))))
  (wb_display_set_opacity display 1.0))

(defun wtom (x)
  (setq tmp (+ (/ MAP_SIZE 2) (/ x CELL_SIZE)))
  (if (< tmp 0) (setq tmp 0))
  (if (>= tmp MAP_SIZE) (setq tmp (- MAP_SIZE 1)))
  tmp)

(defun run nil
  (setq speed (vector 300 300))
  (dotimes (i NB_DIST_SENS)
    (setq d (wb_distance_sensor_get_value (elt ps i)))
    (if (> d 70) (incf d (elt bias_left_follow i)))
    (when (or (> d 70) (< d 0))
      (incf (elt speed LEFT) (* d (elt weights_left i)))
      (incf (elt speed RIGHT) (* d (elt weights_right i))))
    )
  (setf (elt speed LEFT) (if (> (elt speed LEFT) 500) 500 (elt speed LEFT)))
  (setf (elt speed LEFT) (if (< (elt speed LEFT) - 500) -500 (elt speed LEFT)))
  (setf (elt speed RIGHT) (if (> (elt speed RIGHT) 500) 500 (elt speed RIGHT)))
  (setf (elt speed RIGHT) (if (< (elt speed RIGHT) -500) -500 (elt speed RIGHT)))
  (wb_motor_set_velocity left_motor (* SPEED_UNIT (elt speed LEFT)))
  (wb_motor_set_velocity right_motor (* SPEED_UNIT (elt speed RIGHT))))

(defun main nil
  (setq max 0.0)
  (wb_robot_init)
  ;;srand(time(NULL));
  ;; get a handler to the motors and set target position to infinity (speed control).
  (setq left_motor (wb_robot_get_device "left wheel motor"))
  (setq right_motor (wb_robot_get_device "right wheel motor"))
  (wb_motor_set_position left_motor INFINITY)
  (wb_motor_set_position right_motor INFINITY)
  (wb_motor_set_velocity left_motor 0.0)
  (wb_motor_set_velocity right_motor 0.0)
  ;; get a handler to the position sensors and enable them.
  (setq left_position_sensor (wb_robot_get_device "left wheel sensor"))
  (setq right_position_sensor (wb_robot_get_device "right wheel sensor"))
  (wb_position_sensor_enable left_position_sensor TIME_STEP)
  (wb_position_sensor_enable right_position_sensor TIME_STEP)
  ;; required to get the position sensor values
  (wb_robot_step TIME_STEP)
  ;; Initializes tracking and goto structures
  (odometry_track_start_pos
   ot (* ENCODER_UNIT (wb_position_sensor_get_value left_position_sensor))
   (* ENCODER_UNIT (wb_position_sensor_get_value right_position_sensor)))
  (setq ot.result.x 0.0)
  (setq ot.result.y 0.0)
  (setq ot.result.theta (/ (- PI) 2))
  ;; map and sm init to 0  and belief to 1/MAP_SIZE^2
  (dotimes (i MAP_SIZE)
    (dotimes (j MAP_SIZE)
      (setf (aref map i j) 0)
      (setf (aref sm i j)  0)
      (setf (aref belief i j) (/ 1.0 (* MAP_SIZE MAP_SIZE)))))
  ;; map the arena (in map and in sm, sm_inv)
  (do ((i 7 (1+ i)))
      ((>= i 29))
      (setf (aref map i 2) 1)
      (setf (aref sm i 3) 0.9)
      (setf (aref map i 33) 1)
      (setf (aref sm i 32) 0.9))
  (do
   ((j 2 (1+ j)))
   ((>= j 34))
   (setf (aref map 7 j) 1)
   (setf (aref sm 8 j) 0.9)
   (setf (aref map 28 j) 1)
   (setf (aref sm 27 j) 0.9))
  ;; apply a kind of blur on the sensor model
  (dotimes (i MAP_SIZE)
    (dotimes (j MAP_SIZE)
      (when (> (aref sm i j) 0.6)
        (if (and (< (+ i 1) MAP_SIZE) (< (aref sm (+ i 1) j) 0.45))
	    (setf (aref sm (+ i 1) j) 0.45))
	(if (and (> (- i 1) 0) (< (aref sm (- i 1) j) 0.45))
	    (setf (aref sm (- i 1) j) 0.45))
        (if (and (< (+ j 1) MAP_SIZE) (< (aref sm i (+ j 1)) 0.45))
	    (setf (aref sm i (+ j 1)) 0.45))
        (if (and (> (- j 1) > 0) (< (aref sm i (- j 1)) 0.45))
	    (setf (aref sm i (- j 1)) 0.45)))))
  (dotimes (i MAP_SIZE)
    (dotimes (j MAP_SIZE)
      (when (and (> (aref sm i j) 0.3) (< (aref sm i j) 0.6))
        (if (and (< (+ i 1) MAP_SIZE) (< (aref sm (+ i 1) j) 0.2))
	    (setf (aref sm (+ i 1) j) 0.2))
        (if (and (> (- i 1) 0) (< (aref sm (- i 1) j) 0.2))
	    (setf (aref sm (- i 1) j) 0.2))
        (if (and (< (+ j 1) MAP_SIZE) (< (aref sm i (+ j 1)) 0.2))
	    (setf (aref sm i (+ j 1)) 0.2))
        (if (and (> (- j 1) 0) (< (aref sm i (- j 1)) 0.2))
	    (setf (aref sm i (- j 1)) 0.2)))
      (setf (aref sm_inv i j) (- 1 (aref sm i j)))))
  (init_display)
  ;; get the distance sensor devices
  (setq textPS "ps0")
  (dotimes (i NB_DIST_SENS)
    (setf (elt ps i) (wb_robot_get_device textPS))
    (wb_distance_sensor_enable (elt ps i) TIME_STEP)
    (incf (elt textPS 2)))
  ;; enables the keyboard
  (wb_keyboard_enable TIME_STEP)
  ;; main loop
  (setq flag t)
  (while flag
    ;; update the odometric position
    (odometry_track_step_pos
     ot (* ENCODER_UNIT (wb_position_sensor_get_value left_position_sensor))
     (* ENCODER_UNIT (wb_position_sensor_get_value right_position_sensor)))
    ;; update position on the map
    (setq tmp_x robot_x)
    (setq robot_x (wtom ot.result.x))
    (setq tmp_y robot_y)
    (setq robot_y (wtom ot.result.y))
    ;; update belief only if cell changed
    (when (or (not (= robot_x tmp_x)) (not (= robot_y tmp_y)))
      ;; initiate the odometry model
      (dotimes (i MAP_SIZE)
	(dotimes (j MAP_SIZE)
	  (setf (aref om i j) 0.0)))
      ;;compute the odometry model (and spread it over a point
      (setf (aref om robot_x robot_y) (/ 3.0 19))
      (if (< (+ robot_x 1) MAP_SIZE)
	  (setf (aref om (+ robot_x 1) robot_y) (/ 2.0 19)))
      (if (> (- robot_x 1) 0)
	  (setf (aref om (- robot_x - 1) robot_y) (/ 2.0 19)))
      (if (< (+ robot_y 1) MAP_SIZE)
	  (setf (aref om robot_x (+ robot_y 1)) (/ 2.0 19)))
      (if (> (- robot_y 1) 0)
	  (setf (aref om robot_x (- robot_y 1)) (/ 2.0 19)))
      (if (< (+ robot_x 2) MAP_SIZE)
	  (setf (aref om (+ robot_x 2) robot_y) (/ 1.0 19)))
      (if (> (- robot_x 2) 0)
	  (setf (aref om (- robot_x 2) robot_y) (/ 1.0 19)))
      (if (< (+ robot_y 2) MAP_SIZE)
	  (setf (aref om robot_x (+ robot_y 2)) (/ 1.0 19)))
      (if (> (- robot_y 2) 0)
	  (setf (aref om robot_x (- robot_y 2)) (/ 1.0 19)))
      (if (and (< (+ robot_x 1) MAP_SIZE) (< (+ robot_y 1) MAP_SIZE))
	  (setf (aref om (+ robot_x 1) (+ robot_y 1)) (/ 1.0 19)))
      (if (and (> (- robot_x 1) 0) (< (+ robot_y 1) MAP_SIZE))
	  (setf (aref om (- robot_x 1) (+ robot_y 1)) (/ 1.0 19)))
      (if (and (< (+ robot_x 1) MAP_SIZE) (> (- robot_y 1) 0))
	  (setf (aref om (+ robot_x 1) (- robot_y 1)) (/ 1.0 19)))
      (if (and (> (- robot_x 1) 0) (> (- robot_y 1) 0))
	  (setf (aref om (- robot_x 1) (- robot_y 1)) (/ 1.0 19)))
      ;; compute the prediction (convolution of belief and om)
      (setq offset_x tmp_x)
      (setq offset_y tmp_y)
      (do
       ((i offset_x (1+ i)))
       ((>= i (+ MAP_SIZE offset_x)))
       (do ((j offset_y (1+ j)))
	   ((>= j (+ MAP_SIZE offset_y)))
	   (setf (aref prediction (- i offset_x) (- j offset_y)) 0.0)
	   (dotimes (k i)
	     (dotimes (l j)
	       (if (and (> k 0) (< k MAP_SIZE) (> l 0) (< l MAP_SIZE) (> (- i k) 0)
			(< (- i k) MAP_SIZE)
			(> (- j l) 0)
			(< (- j l) MAP_SIZE))
		   (incf (aref prediction (- i offset_x) (- j offset_y))
			 (* (aref belief k l) (aref om (- i k) (- j l)))))))))
      (setq max 0.0)
      ;; compute the belief with prediction and sensor model
      (setq sum 0.0)
      (if (> (wb_distance_sensor_get_value (elt ps 5)) THRESHOLD)
	  (dotimes (i MAP_SIZE)
	    (dotimes (j MAP_SIZE)
	      (setf (aref belief i j) (* (aref prediction i j) (aref sm i j)))
	      (incf sum (aref belief i j))
	      (if (> (aref belief i j) max)
		  (setq max (aref belief i j)))))
	(dotimes (i MAP_SIZE)
	  (dotimes (j MAP_SIZE)
	    (setf (aref belief i j) (* (aref prediction i j) (aref sm_inv i j)))
	    (incf sum (aref belief i j))
	    (if (> (aref belief i j) max)
		(setq max (aref belief i j))))))
      ;; normalize the distribution
      (when (> sum 0.0)
	(dotimes (i MAP_SIZE)
	  (dotimes (j MAP_SIZE)
	    (setf (aref belief i j) (/ (aref belief i j) sum))))
	(setq max (/ max sum)))
      )
    ;; draw belief on display
    (draw_on_display max)
    ;; move the robot
    (run)
    (if (< (wb_robot_step TIME_STEP) 0) (setq flag nil)))
  ;; Necessary to cleanup webots stuff
  (wb_robot_cleanup)
  )
