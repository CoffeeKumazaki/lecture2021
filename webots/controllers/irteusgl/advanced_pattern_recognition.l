;;#include "ann.h"  // definition of the used ANN
(defconstant TRUE 1)
(defconstant FALSE 0)
(defconstant LEFT 0)
(defconstant RIGHT 1)
(defconstant TIME_STEP 64)
(defconstant SPEED_UNIT 0.00628)
;; states (for moving the robot)
(defconstant BED 0)
(defconstant ROTATION 1)
(defconstant RANDOM_WALK 2)
(defconstant DANSE 3)
;; modes (mode of the ANN algorithm)
(defconstant NO_MODE 0)
(defconstant LEARN 1)
(defconstant TEST 2)
;; patterns (a landmark)
(defconstant NUMBER_OF_PATTERNS 5)
(defconstant NO_PATTERN 0)
(defconstant P1 1)
(defconstant P2 2)
(defconstant P3 3)
(defconstant P4 4)
;; samples (an aera of the camera image which correspond to a landmark)
(defconstant SAMPLE_MAX_NUMBER 5) ;;  // how many samples the e-puck can see at the same time
;; devices
(defconstant NB_LEDS 8)
(defconstant NB_DIST_SENS 8)
(defconstant PS_RIGHT_10 0)
(defconstant PS_RIGHT_45 1)
(defconstant PS_RIGHT_90 2)
(defconstant PS_RIGHT_REAR 3)
(defconstant PS_LEFT_REAR 4)
(defconstant PS_LEFT_90 5)
(defconstant PS_LEFT_45 6)
(defconstant PS_LEFT_10 7)
#|
static int state = BED;           // current state of the robot
static int mode = NO_MODE;        // current mode of the ANN algorithm
static int current_pattern = P1;  // current pattern for learning
static float samples[SAMPLE_MAX_NUMBER][SAMPLE_WIDTH * SAMPLE_HEIGHT];
static int sample_counter = 0;
static WbDeviceTag led[NB_LEDS];
static WbDeviceTag ps[NB_DIST_SENS];
static WbDeviceTag cam;
static WbDeviceTag display;
static WbDeviceTag left_motor, right_motor;
static int speed[2] = {0, 0};
static int delta = 0;           // delta between the two wheels
static int internal_state = 0;  // used for the random move and the danse
static int old_key = -1;        // last pressed key stroke
static float error = 1.0;
|#
(defun usage nil
  (format t "Commands (from keyboard):~%")
  (format t "~%")
  (format t "  1          : Select the pattern 1 for learning~%")
  (format t "  2          : Select the pattern 2 for learning~%")
  (format t "  3          : Select the pattern 3 for learning~%")
  (format t "  4          : Select the pattern 4 for learning~%")
  (format t "~%")
  (format t "  Up arrow   : Select the next pattern for learning~%")
  (format t "  Down arrow : Select the previous pattern for learning~%")
  (format t "~%")
  (format t "  L          : Enable (or disable) the learning mode~%")
  (format t "  T          : Enable (or disable) the testing mode~%")
  (format t "~%")
  (format t "  O          : Load the weights stored in the weights.w file~%")
  (format t "  S          : Save the weights stored in the weights.w file~%")
  (format t "~%")
  (format t "  B          : Stop the motors of the e-puck~%")
  (format t "  R          : Rotate the e-puck~%")
  (format t "  W          : Random walk of the e-puck~%")
  (format t "  D          : the e-puck danse~%")
  )
(defun my_round (x) (if (>= x 0) (round (+ x 0.5)) (round (- x 0.5))))

(defun keyboard_manager nil
  (setq key (wb_keyboard_get_key))
  (when (not (= key old_key))
    (setq old_key key)
    (cond
     ((memq key (list #\1 #\2 #\3 #\4))
      (setq current_pattern (- key #\0)))
     ((= key #\B)
      (setq state BED)
      (format t "State of the robot: Bed~%"))
     ((= key #\R)
      (setq state ROTATION)
      (format t "State of the robot: Rotation~%"))
     ((= key #\W)
      (setq state RANDOM_WALK)
      (setq delta 0)
      (setq internal_state 0)
      (format t "State of the robot: Random walk~%"))
     ((= key #\D)
      (setq state DANSE)
      (setq delta 0)
      (setq internal_state 0)
      (format t "State of the robot: Danse~%"))
     ((= key #\L)
      (cond
       ((= mode LEARN)
	(setq mode NO_MODE)
	(format t "Mode of the algorithm: No mode~%"))
       (t (setq mode LEARN)
          (format t "Mode of the algorithm: Learn~%"))))
     ((= key #\T)
      (cond
       ((= mode TEST)
	(setq mode NO_MODE)
	(format t "Mode of the algorithm: No mode~%"))
       (t 
          (setq mode TEST)
          (format t "Mode of the algorithm: Test~%"))))
     ((= key WB_KEYBOARD_UP)
      (incf current_pattern)
      (setq current_pattern (mod NUMBER_OF_PATTERNS current_pattern)))
     ((= key WB_KEYBOARD_DOWN)
      (decf current_pattern)
      (when (< current_pattern 0)
	(setq current_pattern (- NUMBER_OF_PATTERNS 1))))
     ((= key #\S)
      (SaveNetworkWeights &network "weights.w")
      (format t "Weights of the ANN saved in weights.w~%"))
     ((= key #\O)
      (LoadNetworkWeights &network "weights.w")
      (format t "weights.w loaded in the weights of the ANN~%"))
     ((= key #\P)
      (format t "Network is:~%");
      (PrintNetwork &network))
     (t nil)))
  (when (or (= key WB_KEYBOARD_UP) (= key WB_KEYBOARD_DOWN)
	    (and (>= key #\1) (<= key #\4)))
    (if (= current_pattern NO_PATTERN)
        (format t "No Pattern selected for learning~%")
      (format t "Pattern ~A is selected for learning~%" current_pattern))
    )
  )

(defun robot_state_manager nil
  (cond
   ((= state BED)
    (setf (elt speed LEFT) 0)
    (setf (elt speed RIGHT) 0))
   ((= state ROTATION)
    (setf (elt speed LEFT) 200)
    (setf (elt speed RIGHT) -200))
   ((= state RANDOM_WALK)
    (setq left_obstacle
	  (+
	   (wb_distance_sensor_get_value (elt ps 5))
	   (wb_distance_sensor_get_value (elt ps 6))
	   (wb_distance_sensor_get_value (elt ps 7))))
    (setq right_obstacle
	  (+
	   (wb_distance_sensor_get_value (elt ps 0))
	   (wb_distance_sensor_get_value (elt ps 1))
	   (wb_distance_sensor_get_value (elt ps 2))))
    (setq d (- right_obstacle left_obstacle))
    (if (= internal_state 0)
        (incf delta (round (random 5.0)))
      (decf delta (round (random 5.0))))
    (if (> delta 100)
	(setq internal_state 1)
      (if (< delta -100)
	  (setq internal_state 0)))
    (setf (elt speed RIGHT) (+ 200 d delta))
    (setf (elt speed LEFT) (- 200 d delta)))
   ((= state DANSE)
    (setq turn 25)
    (setq forward 200)
    (cond
     ((> internal_state 200)
       (setq internal_state 0))
     ((> internal_state 180)
      (setf (elt speed LEFT) turn)
      (setf (elt speed RIGHT) (- turn)))
     ((> internal_state 140)
      (setf (elt speed LEFT) (- turn))
      (setf (elt speed RIGHT) turn))
     ((> internal_state 120)
      (setf (elt speed LEFT) turn)
      (setf (elt speed RIGHT) (- turn)))
     ((> internal_state 100)
      (setf (elt speed LEFT) (- forward))
      (setf (elt speed RIGHT) (- forward)))
     ((> internal_state 80)
      (setf (elt speed LEFT) turn)
      (setf (elt speed RIGHT) (- turn)))
     ((> internal_state 40)
      (setf (elt speed LEFT) (- turn))
      (setf (elt speed RIGHT) turn))
     ((> internal_state 20)
      (setf (elt speed LEFT) turn)
      (setf (elt speed RIGHT) (- turn)))
     ((> internal_state 0)
      (setf (elt speed LEFT) forward)
      (setf (elt speed RIGHT) forward)))
    (incf internal_state))
   (t nil))
  )

(defun detect_blobs nil
  ;;int i, j, k, x, y;
  (setq image (wb_camera_get_image cam))
  (setq width (wb_camera_get_width cam))
  (setq height (wb_camera_get_height cam))
  (setq iref (wb_display_image_new display width height image WB_IMAGE_BGRA))
  (wb_display_image_paste display iref 0 0 false)
  (setq blue_pixel_detected FALSE)
  (setq sample_right 0)
  (setq sample_left width)
  (setq sample_up 0)
  (setq sample_down height)
  (setq sample_counter 0)
  (dotimes (i width)
    (setq blue_pixel_on_the_column FALSE)
    (dotimes (j height)
      (setq r (wb_camera_image_get_red image width i j))
      (setq g (wb_camera_image_get_green image width i j))
      (setq b (wb_camera_image_get_blue image width i j))
      (when (and (< r 150) (< g 150) (> b 150))
        (setq blue_pixel_detected TRUE)
        (setq blue_pixel_on_the_column TRUE)
        (if (< sample_right i) (setq sample_right i))
        (if (> sample_left i) (setq sample_left i))
        (if (< sample_up j) (setq sample_up j))
        (if (> sample_down j) (setq sample_down j)))))
  (when ((i == width - 1 || blue_pixel_on_the_column == FALSE) && blue_pixel_detected == TRUE)
    (setq sample_width (- sample_right sample_left -1))
    (setq sample_height (- sample_up sample_down))
    (when (sample_width > 1 && sample_height > 1 && sample_counter < SAMPLE_MAX_NUMBER)
      (dotimes (x SAMPLE_WIDTH)
	(dotimes (y SAMPLE_HEIGHT)
	  (setq tmp_i (+ sample_left (/ (* (round x) sample_width) (float SAMPLE_WIDTH))))
	  (setq tmp_j (+ sample_down (/ (* (round y) sample_height) (float SAMPLE_HEIGHT))))
	  (setq value (wb_camera_image_get_blue image width tmp_i tmp_j))
	  (setf (aref samples sample_counter (+ (* SAMPLE_WIDTH y) x)) (* (/ 1.0 255.0) value))
	  (wb_display_set_color display (logior (ash value 16)  (ash value 8) value))
	  (wb_display_draw_pixel display (+ x (* sample_counter (+ SAMPLE_WIDTH 1))) y)))
      (incf sample_counter))
    (setq blue_pixel_detected FALSE)
    (setq sample_left width)
    (setq sample_right 0)
    (setq sample_up 0)
    (setq sample_down height))
  (wb_display_set_color display 0xFF00FF)
  (dotimes (x (* sample_counter (+ SAMPLE_WIDTH 1)))
    (wb_display_draw_pixel display x SAMPLE_HEIGHT))
  (dotimes (k sample_counter)
    (dotimes (y SAMPLE_HEIGHT)
      (wb_display_draw_pixel display (+ k (* (+ 1 k) SAMPLE_WIDTH)) y)))
  )
#|
(defun print_samples nil
  (dotimes (k sample_counter)
    char big_buffer[6*SAMPLE_WIDTH*SAMPLE_HEIGHT+SAMPLE_HEIGHT+1] = "~%";
    for (j=0;j<SAMPLE_HEIGHT;j++){
      for (i=0;i<SAMPLE_WIDTH;i++) {
        char mini_buffer[6];
        s(format t mini_buffer,"%1.3f ",samples[k][i+j*SAMPLE_WIDTH]);
        strcat(big_buffer,mini_buffer);
      }
      strcat(big_buffer,"~%");
    }
    (format t "%s",big_buffer);
  }
|#

(defun run nil
  (keyboard_manager)
  (robot_state_manager)
  (detect_blobs)
  ;; (print_samples)
  (when
      (and
       (= mode LEARN)
       (= sample_counter 1)
       (>= current_pattern P1)
       (<= current_pattern P4))
    (setq output (float-vector 0.0 0.0 0.0 0.0))
    (setf (elt output (- current_pattern 1)) 1.0)

    (InputToNetwork &network (aref samples 0 0))
    (ActivateNetwork &network)
    (setq error (TrainNetwork &network (elt &output 0)))
    (format t "Learned P~A. Resulted error: ~A~%" current_pattern error))
  (when (and (= mode TEST) (> sample_counter 0))
    (dotimes (k sample_counter)
      (InputToNetwork &network (aref &samples k 0))
      (ActivateNetwork &network)
      (PrintNetworkOutput &network)
      (setq layer_t output_layer (elt network.layers (- network.size 1)))
      (setq max -666)
      (setq max_index -1)
      (dotimes (i output_layer.depth)
	(when (> (elt output_layer.y i) max)
          (setq max_index i)
          (setq max (elt output_layer.y i))))
      (format t "I guess that I see the landmark P~A~%" (+ max_index 1))))
  (wb_motor_set_velocity left_motor (* SPEED_UNIT (elt speed LEFT)))
  (wb_motor_set_velocity right_motor (* SPEED_UNIT (elt speed RIGHT)))
  TIME_STEP)

(defun main nil
  (wb_robot_init)
  (usage)
  (RandomizeNetwork &network)
  ;;(srand (time 0))
  (setq text "led0")
  (dotimes (i NB_LEDS)
    (setf (elt led i) (wb_robot_get_device text))
    (wb_led_set (elt led i) FALSE)
    (incf (elt text 3)))
  (setqr textPS "ps0")
  (dotimes (i NB_DIST_SENS)
    (setf (elt ps i) (wb_robot_get_device textPS))
    (wb_distance_sensor_enable (elt ps i) TIME_STEP)
    (incf (elt textPS 2)))
  (setq cam (wb_robot_get_device "camera"))
  (wb_camera_enable cam TIME_STEP)
  (setq display (wb_robot_get_device "display"))
  (wb_keyboard_enable TIME_STEP)
  (setq left_motor (wb_robot_get_device "left wheel motor"))
  (setq right_motor (wb_robot_get_device "right wheel motor"))
  (wb_motor_set_position left_motor INFINITY)
  (wb_motor_set_position right_motor INFINITY)
  (wb_motor_set_velocity left_motor 0.0)
  (wb_motor_set_velocity right_motor 0.0)
  (while (not (= wb_robot_step(TIME_STEP) -1)) (run))
  (wb_robot_cleanup)
  )
